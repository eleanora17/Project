# from common.initialize import getDriver
from ..core import cactions
from selenium.webdriver.common.by import By
from selenium.common import StaleElementReferenceException, NoSuchElementException, InvalidSelectorException, NoSuchAttributeException
# from ..common.logger import __exe_logger
from .. import __exe_logger


__total_attempts=15
__max_depth = 0
#Function which returns xpath using javascript
def __get_element_xpath(element):
    action = """
        function getElementXPath(element) {
            if (!element || !element.tagName || element.tagName.toLowerCase() === 'html' || element.tagName.toLowerCase() === 'body') {
                return '//' + element.tagName.toLowerCase();
            }
            var path = '';
            var siblings = element.parentNode.childNodes;
            var index = 1;
            for (var i = 0; i < siblings.length; i++) {
                var sibling = siblings[i];
                if (sibling === element) {
                    path = getElementXPath(element.parentNode) + '/' + element.tagName.toLowerCase() + '[' + index + ']';
                    break;
                }
                if (sibling.nodeType === 1 && sibling.tagName === element.tagName) {
                    index++;
                }
            }
            return path;
        }
        return getElementXPath(arguments[0]);
        """
    return cactions.execute_javascript(action, element)

# This function holds core functionality  
def __search_for_element(text='', tag_name='', attribute_name='', attribute_value='', current_root='', max_depth=None, offset=0, attempt=1, total_attempts=__total_attempts):
    global __max_depth , __total_attempts

    msg_for = "context" if current_root != "" and current_root !='' else "element"
    msg = (
    f"text:{text} " if text else "" +
    f"tag:{tag_name} " if tag_name else "" +
    f"attribute Type:{attribute_name} " if attribute_name else "" +
    f"attribute value:{attribute_value} " if attribute_value else "" +
    f"context:{current_root} " if current_root else ""
).strip()
    
    __exe_logger.info(f"Attempting to locate element by {msg}")
    __exe_logger.debug(f"text:'{text}', tag:'{tag_name}', attribute:'{attribute_name}', value:'{attribute_value}', context:'{current_root}', offset:{offset}, total attempts:{total_attempts}")
    root_xpath=current_root if current_root!='' else ""
    old_xpath = root_xpath
    depth = 0
    while attempt <= total_attempts:
        __total_attempts-=1
        depth+=1
        __max_depth+=1
        try:

            try:
                # root_element = cactions.find_element_by(element_xpath=root_xpath)
                xpath = root_xpath
                if text != '' and tag_name != '' and attribute_name != '' and attribute_value != '':
                    xpath += f"//{tag_name}[@{attribute_name}='{attribute_value} and text()='{text}']"

                elif text != '' and tag_name != '' and attribute_value != '':
                    xpath += f"//{tag_name}[@*='{attribute_value} and text()='{text}']"

                elif tag_name != '' and attribute_name!= '' and attribute_value != '':
                    xpath += f"//{tag_name}[@{attribute_name}='{attribute_value}']"

                elif text != '' and tag_name != '' and (tag_name == 'input' or tag_name=='textarea'):
                    xpath += f"//*[text()='{text}' or  @*='{text}']"

                elif text != '' and tag_name != '':
                    xpath += f"//{tag_name}[text()='{text}' or  @*='{text}']"

                elif attribute_value != '' and tag_name != '':
                    xpath += f"//{tag_name}[@*='{attribute_value}']"

                elif text != '':
                    xpath += f"//*[@*='{text}' or text()='{text}']"

                elif tag_name != '':
                    xpath += f"//{tag_name}"

                if old_xpath != xpath:
                    __exe_logger.info(f"Selected xpath :{xpath}")

                old_xpath = xpath
                
                current_element = cactions.find_elements_by(element_xpath=xpath)
                
                if current_element and len(current_element)>offset:
                    __exe_logger.debug(f"Found current element")
                    if current_element[offset].tag_name in ['a', 'button', 'input','textarea']:
                        return xpath
                    
                    if tag_name=="input" or tag_name =='textarea':                        
                        if  max_depth == None or depth<max_depth:
                            xpath+='/..'
                            return __search_for_element(tag_name=tag_name, current_root=xpath, max_depth=max_depth, attempt=attempt)
                    else:
                        return xpath
            except (StaleElementReferenceException, NoSuchElementException, InvalidSelectorException):
                pass

            if max_depth == None or  depth<max_depth:
                if root_xpath !='' :
                    root_xpath+='/..'

        except (NoSuchAttributeException, NoSuchElementException, StaleElementReferenceException, InvalidSelectorException, AttributeError ):
            pass
    
        __exe_logger.error(f"Retrying... Attempt {attempt} to find {msg_for} with xpath: {xpath}")
        cactions.sleep(1)
        attempt += 1

    __exe_logger.error(f"{msg_for} not found after {total_attempts} attempts")
    raise NoSuchElementException(f"{msg_for} not found after {total_attempts} attempts")



def get_xpath_by(text='', tag_name='', attribute_name='', attribute_value='', context='', max_depth=None, offset=0, total_attempts=15):
    r"""
    Dyanamic Element Finder.

    Args:
        text (str, optional): Text content to search within elements.
        tag_name (str, optional): HTML tag name to filter elements by.
        attribute_name (str, optional): HTML attribute name to filter elements by.
        attribute_value (str, optional): HTML attribute value to filter elements by.
        context (str, optional): Optional context or parent element to start search from.
        max_depth (str, optional): Optional max_depth to limit the element finder.
        offset (int, optional): Position of element 
        total_attempt (int, optional): Number of attempts to locate elements before raising an exception.

    Raises:
        NoSuchElementException: If the element is not found after all attempts.
    """

    cactions.wait_for_page_load()
    context_list=context.split(",")
    root=""

    if context == "":
        return_xpath = __search_for_element(text=text, tag_name=tag_name, attribute_name=attribute_name, attribute_value=attribute_value, max_depth=max_depth, offset=offset, total_attempts=total_attempts)
        element = cactions.find_element_by(element_xpath=return_xpath)
        cactions.scrollToElement(element)
        # cactions.sleep(2)
        __exe_logger.debug(f"Generated xpath without context : {return_xpath}. {("Max depth: "+str(max_depth)) if max_depth !=None else ""}")
        return return_xpath
    
    flag = True
    for context_item in context_list:
        # print("root =>",root)
        if context_item != "":
            if flag:
                current_root = __search_for_element(text=context_item, current_root=root, total_attempts=total_attempts)
                __exe_logger.debug(f"context '{context_item}' with xpath => {current_root}")
                flag = False

            # current_root = __search_for_element(text=text, tag_name=tag_name, attribute_name=attribute_name, attribute_value=attribute_value, current_root=current_root, offset=offset, total_attempts=total_attempts)
            __exe_logger.debug(f"finding '{text}' with respect to context '{context_item}'.")
            current_root = current_root + "/.."
            if tag_name == "input" or tag_name == "textarea":
                root = __search_for_element(text=text,  tag_name=tag_name, current_root=current_root, max_depth=max_depth if max_depth !=None else 5, total_attempts=total_attempts)
            #     root = __backtrack_element(tag_name=tag_name, attribute_name=attribute_name, attribute_value=attribute_value, current_root=current_root, offset=offset, total_attempts=total_attempts)
            else:
                root = __search_for_element(text=text, tag_name=tag_name, attribute_name=attribute_name, attribute_value=attribute_value, current_root=current_root, max_depth=max_depth, offset=offset, total_attempts=total_attempts)

    element = cactions.find_element_by(element_xpath=root)
    cactions.scrollToElement(element)
    __exe_logger.debug(f"Generated xpath with context {context_list} : {root}. {("Max depth: "+str(max_depth)) if max_depth !=None else ""}")
    return root

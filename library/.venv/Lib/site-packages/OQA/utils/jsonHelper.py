import json, os
from OQA.utils import utils
import datetime

# from .. import __config

def __join_filepath(filename:str="", location:str="", save:bool=False):
    # print(__config)
    # print("__JOIN PATH", filename, location)
    filepath = os.path.join(location,filename)
    if location == "":
        from .. import __config

        if save:
            filepath = os.path.join(__config["testFolder"],filename)
        else:
            location = __config["dataSpace"]
            filepath = utils.findDataPath(file_name=filename, user_path=location)
        return filepath

    else: 
        if save:
            filepath  = os.path.join(location, filename)
            return filepath

        elif os.path.exists(filepath):
            return filepath
    
        
    
    raise FileNotFoundError(f"filename:{filename}, looking at:{filepath}")

def read_json_file(filename:str, location:str=""):
    # print("read json file",filename, location)
    # config="dataSpace"
    try:
        filepath = __join_filepath(filename, location)
        # print(filepath, "filepath from read json")
        try:
            # Opening JSON file
            f = open(filepath)
            data = json.load(f)
            f.close()
            return data
        except(OSError, json.JSONDecodeError, TypeError) as e:
            raise ValueError()
        
    except ValueError:
        raise FileNotFoundError(f"filname:{filename} not Found in config.")

    

def read_json_data(keys: str, filename: str, location: str = ""):
    # filepath = utils.findDataPath(filename, filepath)
    json_data = read_json_file(filename, location)

    data = {key.strip(): json_data[key.strip()] for key in keys.split(",") if key.strip() in json_data}
    return data

def save_as_json_file(data: dict, filename: str = "", location="",overwrite=False ):
    r"""
    Save JSON data to a file.

    Args:
        data (json): The JSON data to save.
        location (str, optional): The directory location where the file should be saved. Default is None (current directory).
        filename (str, optional): The name of the file. If not provided, a timestamped filename will be generated.

    Example usage:
        >>> savefile({"key": "value"}, location="/path/to/directory/", filename="current_timestamp.json")
        Data saved in /path/to/directory/current_timestamp.json
    """

    if filename == "":
        filename = "outputJson_" + str(datetime.datetime.now().strftime("%Y_%m_%d_%H_%M_%S")) + ".json"

    filepath = __join_filepath(filename, location, save=True)
    
    try:
        if os.path.exists(filepath) and overwrite==False:
            # read existing file and append new data
            with open(filepath, "r") as f:
                json_data = json.load(f)
                dict_data = dict(json_data)
            dict_data.update(data)
        else:
            # create new json
            dict_data = data
        with open(filepath, "w") as fs:
            json.dump(dict_data, fs, indent=4)
        # print("Data saved in", filepath)
        print("\033[92mData saved in", filepath, "\033[0m")

    except IOError as e:
        # print(f"Error saving file: {e}")
        print("\033[91mError saving file: {e}\033[0m")

        

def edit_json_file(key, value, filename:str, location:str=""):
    r"""
    Edit a JSON file by updating or adding new data.

    Args:
    - key (str, optional): If provided, specifies a key in the JSON to update. If None, data is merged into the top-level JSON structure.
    - value : containing data to be added or updated. this could be string or dict or list
    - filepath (str): The path to the JSON file.

    Raises:
    - Any exceptions encountered during file operations or JSON manipulation.

    """

    filepath = __join_filepath(filename, location, save=True)
    
    try:
        existing_data = {}
        try:
            # print(filename, location)
            # print(existing_data,"read data1")
            existing_data = read_json_file(filename,location)
            # print(existing_data,"read data")
        except (FileNotFoundError) as e:
            print(e)

        if value is not None or value != "":
            if key is not None or key != "":
                existing_data[key]=value
            else:
                print("Cannot update json without key")
        else:
            print("Cannot update json without value")
        

        with open(filepath, "w") as fs:
            json.dump(existing_data, fs, indent=4)

        print("Data updated & saved in", filepath)
        # print(existing_data)

    except Exception as e:
        print(e)


def convert_object_to_dict(obj):
    # If it's a basic type (int, float, str, bool), return it directly
    if isinstance(obj, (int, float, str, bool)):
        return obj
    
    # If the object is a list, recursively convert its items
    if isinstance(obj, list):
        return [convert_object_to_dict(item) for item in obj]
    
    # If the object is a dictionary, recursively convert its values
    if isinstance(obj, dict):
        return {key: convert_object_to_dict(value) for key, value in obj.items()}
    
    # If the object is a JSON string, parse it to handle as a dict or list
    if isinstance(obj, str):
        try:
            # Try to parse the string as JSON
            parsed_json = json.loads(obj)
            return convert_object_to_dict(parsed_json)  # Recursively handle the parsed JSON
        except json.JSONDecodeError:
            # If it's not valid JSON, treat it as a regular string
            return obj
    
    # If the object has a __dict__ attribute (custom object), convert its attributes
    if hasattr(obj, "__dict__"):
        return {key: convert_object_to_dict(getattr(obj, key)) for key in dir(obj)
                if not key.startswith('__') and not callable(getattr(obj, key))}
    
    # Fallback case: Try to convert the object to a string if it's not serializable
    try:
        return str(obj)
    except Exception as e:
        return f"<Object could not be serialized: {e}>"
    
    return obj
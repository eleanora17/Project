import datetime
import os
import shutil
import re
# from PIL import Image
from . import __getDictionary, __setDictionary, __loadDictionary
import csv



def getCurrentDateTime(delay_min=0):
    # Initializing a date and time
    date_and_time = datetime.datetime.now()

    # print("Original time:")
    # print(date_and_time.strftime("%Y/%m/%d, %H:%M:%S.%f")[:-3])

    # Calling the timedelta() function
    time_change = datetime.timedelta(minutes=delay_min)
    new_time = date_and_time + time_change

    # Printing the new datetime object
    # print("changed time:")
    new_time_list = new_time.strftime("%Y/%m/%d, %H:%M:%S.%f")[:-3].split(',')
    # print("Date: {0}".format(new_time_list[0]))
    # print("Time: {0}".format(new_time_list[1]))
    return new_time_list[0], new_time_list[1]


def findDataPath(file_name, user_path=''):
    if user_path != '':
        # user_path = re.escape(user_path)
        data_dict_path = os.path.normpath(user_path)
        data_dict_path = os.path.abspath(data_dict_path)

    else:
        from .. import __config
        datapace = __config.get('dataSpace',"")
        if datapace == "":
            datapace = os.getcwd()
        data_dict_path = os.path.normpath(datapace)

    full_path = os.path.normpath(data_dict_path)
    ignored_dirs = ['System Volume Information', '$Recycle.Bin', 'Windows', 'Program Files', 'Program Files (x86)',
                    'AppData', 'Temp', '/proc', '/sys', '/dev', '/run', '/var/lib', '/var/run', '/var/cache', '/tmp',
                    '/mnt', '/media']
    
    for dirpath, dirnames, filenames in os.walk(full_path):
        dirnames[:] = [d for d in dirnames if d not in ignored_dirs]
        for filename in filenames:
            if filename == file_name:
                file_path = os.path.join(dirpath, filename)
                # print(f"File found: {file_path}")
                return file_path  # Exit the function immediately
    raise FileNotFoundError


def move_file(source_file, destination_dir):
    print("Source is {0} and destination is {1}".format(source_file, destination_dir))
    global destination_file
    try:
        # Ensure the destination directory exists
        if not os.path.exists(destination_dir):
            os.makedirs(destination_dir)

        # Get the filename from the source file path
        file_name = os.path.basename(source_file)

        # Construct the destination file path
        destination_file = os.path.join(destination_dir, file_name)

        # Move the file to the destination directory
        shutil.move(source_file, destination_dir)
        # Return the new file path
        return destination_file
    except Exception as e:
        print("Exception occurred while moving the file. {0}".format(e))


def delete_file(file_path):
    # Delete the file
    os.remove(file_path)


def normalize_path(user_path):
    user_path = re.escape(user_path)
    normalized_path = os.path.normpath(user_path)
    return normalized_path

def is_relative_path(path):
    return not os.path.isabs(path)

def create_folder(path):
    os.makedirs(path, exist_ok=True)


# def compress_and_resize_image(image_path, reduce_width_by_per=0.5, reduce_height_by_per=0.5, reduce_quality_by_per=0.5):
#     im = Image.open(image_path)
#     # Get the current width and height
#     width, height = im.size

#     reduce_width = 1 - reduce_width_by_per
#     reduce_height = 1 - reduce_height_by_per
#     reduce_quality = 100 - reduce_quality_by_per
#     # Calculate the new dimensions
#     new_width = int(width * reduce_width)
#     new_height = int(height * reduce_height)

#     # Resize the image
#     resized_image = im.resize((new_width, new_height))
#     resized_image.save(image_path, quality=reduce_quality, optimize=False)
#     return image_path


def setDictionary(key, value):
    r"""
    Set a key-value pair in the global dictionary.

    Args:
        key: The key to set in the dictionary.
        value: The value corresponding to the key.

    Returns:
        None
    """
    __setDictionary(key,value)

def getDictionary(key=None):
    r"""
    Retrieve a value from the global dictionary.

    Args:
        key (optional): The key to retrieve from the dictionary. If not provided,
                        returns the entire dictionary.

    Returns:
        If `key` is provided, returns the value associated with `key` in the dictionary.
        If `key` is not provided, returns the entire dictionary as a dictionary object.
    """
    return __getDictionary(key)

def loadDictionary(data:dict):
    r"""
    load dict

    Args:
        data : type(dict)

    Returns:
       Nothing
    """
    return __loadDictionary(data)


def get_abs_path(path:str=""):
    r"""
    This function returns abs location path.
    by 
    1. location given as params.
    """

    if path == "":
        raise ValueError("Empty location provided. Please provide a valid location.")

    filepath = os.path.abspath(path) if is_relative_path(path) else normalize_path(path)

    if os.path.exists(filepath):
        return filepath
    
    raise FileNotFoundError(f"filepath:{filepath}")


def printMsg(params:dict)->str:
    msg = ""
    for key, value in params.items():
        if value != '' and value != 0 and value!=None:
            msg +=f"{key}: {value}, "

    return msg

def DeDuplicate_Array(array:list)->list:
    return list(set(array))

def get_output_folder_name():
    from .. import __config
    return __config['testFolder']

def rename_file(source_folder, old_file_name, new_file_name):
    """
    Renames a file in the specified source folder.

    Parameters:
        source_folder (str): The folder where the file is located.
        old_file_name (str): The current name of the file, including its extension.
        new_file_name (str): The new name for the file, including its extension.
        
    Returns:
        str: A message indicating success or failure.
    """
    # Construct full paths
    old_file_path = os.path.join(source_folder, old_file_name)
    new_file_path = os.path.join(source_folder, new_file_name)
    print(f"Old file path {old_file_path}")
    print(f"New file path {new_file_path}")
    
    try:
        # Check if the old file exists
        if not os.path.exists(old_file_path):
            return f"Error: The file '{old_file_name}' does not exist in the folder '{source_folder}'."
        
        # Rename the file
        os.rename(old_file_path, new_file_path)
        return f"File renamed successfully from '{old_file_name}' to '{new_file_name}'."
    
    except Exception as e:
        return f"An error occurred: {e}"
    
def sanitize_string(query_string):
    """
    Removes invalid characters from the string.
    
    Parameters:
        query_string (str): The original string.
    
    Returns:
        str: A sanitized string.
    """
    # Replace invalid characters with underscores
    invalid_chars = r'\/:*?"<>|'
    for char in invalid_chars:
        query_string = query_string.replace(char, "_")
    return query_string

def read_csv(file_path):
    """
    Reads a CSV file and returns a list of dictionaries where each dictionary represents a row in the CSV.

    :param file_path: Path to the CSV file.
    :return: List of dictionaries containing the CSV data.
    """
    data = []
    with open(file_path, mode='r') as file:
        csv_reader = csv.DictReader(file)
        for row in csv_reader:
            data.append(row)
    return data


def get_test_output_folder():
    from .. import __config
    return __config['testFolder']


def get_data_folder():
    from .. import __config
    return __config['dataSpace']


def get_temp_folder():
    from .. import __config
    return __config['tempSpace']


def get_sensitive_data_folder():
    from .. import __config
    sensitive_data_path = __config['dataSpace']  + os.sep + 'sensitive' + os.sep + 'data'
    return sensitive_data_path
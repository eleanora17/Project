# This Module focus on only printing data on console
import importlib.metadata as metadata
import sys, requests, os
from OQA.utils import jsonHelper
from datetime import datetime, timezone
# from OQA.api import rest
# from OQA.core import cactions

# from .. import __exe_logger, __config

__metaData = {}
__exe_logger = {}
__config = {}
__timer={}

def init_metadata(config, exe_logger):
    global __config, __exe_logger
    __config = config
    __exe_logger = exe_logger

    setMetadata()
    print_metadata(__metaData['main'])
    beginTiming('execution')
    # return metaData

def setMetadata():
    global __metaData
    metadata_exclude_options=['workspace','Jira','getMOSVersion']
    configs = __config
    metaData = {"testScript":sys.argv}
    metaData["QA Automation Library, Version"]=metadata.version("qa-library")
    for config in __config:
        if config not in metadata_exclude_options:
            metaData[config]=configs[config]
    __metaData["main"] = metaData

    # if "getMOSVersion" in __config and __config["getMOSVersion"]:
    #     __metaData['tanent']=getMOSVersion()


def Heading(title):
    width = os.get_terminal_size().columns
    available_space  = width-len(title)-36
    dash = round(available_space  // 2)
    __exe_logger.info("-" * dash + " " + title + " " + "-" * dash)

def print_metadata(metaData):
    __exe_logger.info(f"QA Automation Library, Version: {metadata.version("qa-library")}")
    Heading("METADATA START")
    data = dict(sorted(metaData.items())) 
    data.pop("QA Automation Library, Version")
    time = data['testFolder']
    id = time.split('Test_')[1]
    __exe_logger.info(f"TestID: {id}")
    for key in data:
        __exe_logger.info(f"{key}: {data[key]}")
    Heading("METADATA END")
    print()
    
def set_additional_metadata(url, driver=None):
    data = {}
    if driver is not None:
        options = ['browserName','browserVersion', "platformName"]
        data = filter_browser_capabilities(driver, options)
        
    data['url']=url    
    __metaData["browser"] = data

    if "getMOSVersion" in __config and __config["getMOSVersion"]:
        __metaData['tanent']=getMOSVersion(url)



def filter_browser_capabilities(driver, contains:list):
    browser_details = driver.capabilities
    options = {key.lower(): value for key, value in browser_details.items()}
    
    if not contains or contains == []:
        return browser_details
    
    matching_details = {}
    
    for contain in contains:
        contain_lower = contain.lower()
        for key, value in options.items():
            if contain_lower in key:
                matching_details[contain] = value
    
    return matching_details
            

def get_metadata():
    __metaData
    timer = finishTiming("execution")
    return {**__metaData, 'execution':timer}

# https://qa.staging.oqton.ai/js/config.js
# use this link to get app version

def getMOSVersion(url:str="https://qa.staging.oqton.ai"):
    path = "js/config.js"
    full_url = None
    if url.endswith("/"):
        full_url = url+path
    else:
        full_url = url+"/"+path
    mos = requests.get(full_url, timeout=30)
    mos = mos.text
    mos = mos.replace(";", "")
    mos = mos.strip().split("\n")

    data = {}
    for eachConfig in mos[1:]:
        if eachConfig != "":
            tuple = eachConfig.strip().split("=")
            key = tuple[0].replace("'","").strip()
            value = tuple[1].replace("'","").strip()
            data[key]=value
        
    return data

def beginTiming(title:str):
    global __timer
    __timer[title]={
        "start":datetime.now(timezone.utc)
    }

def finishTiming(title:str):
    global __timer
    if title in __timer:
        end_time = datetime.now(timezone.utc)
        start_time = __timer[title]['start']

        # Get the total seconds from the timedelta object
        duration_seconds = (end_time - start_time).total_seconds()

        # Break down the duration into days, hours, minutes, and seconds
        days, remainder = divmod(duration_seconds, 86400)  # 86400 seconds in a day
        hours, remainder = divmod(remainder, 3600)  # 3600 seconds in an hour
        minutes, seconds = divmod(remainder, 60)  # 60 seconds in a minute

        # Build the formatted string
        formatted_duration = ''
        if days > 0:
            formatted_duration = f"{int(days)} day,"
        if hours > 0:
            formatted_duration = f"{formatted_duration} {int(hours):02}h"
        if minutes > 0:
            formatted_duration = f"{formatted_duration} {int(minutes):02}m"
        if seconds > 0:
            formatted_duration = f"{formatted_duration} {int(seconds):02}s"

        # Save the result
        __timer[title] = {
            "start": start_time.isoformat(),
            "end": end_time.isoformat(),
            "duration": formatted_duration.strip()
        }
        return __timer[title]
    else:
        print(f"No timer found for '{title}'.")
    
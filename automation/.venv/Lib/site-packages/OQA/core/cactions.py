import os
import re
import time
from PIL import Image

from ..common import initialize
from selenium.common import StaleElementReferenceException, NoSuchElementException
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException
from selenium.webdriver import ActionChains, Keys
from selenium.webdriver.common.by import By
from selenium.webdriver.remote.webelement import WebElement
from ..utils import utils, ddtHelper
from OQA.lib import metadata_helper
from .. import __config
from .. import __exe_logger

global driver
global global_timeout
global wait
global action_chains


def init_global_param():
    global wait
    global action_chains
    global global_timeout

    if __config["skippSpeedTest"] is not True:
        global_timeout = 20 * int(__config["speed_factor"])
    else:
        global_timeout = 20
    wait = WebDriverWait(driver, global_timeout)
    action_chains = ActionChains(driver)


# Wrapper method for checking that an element is present on the DOM of a page.
def wait_for_presence_of_element(element_id='', element_xpath='', total_attempt=1):
    wait_for_page_load()
    attempt = 1
    while True:
        # __exe_logger.info(f"attempt:{attempt}, Waiting for presence of element. ")
        try:
            if element_id != '':
                element = wait.until(EC.presence_of_element_located((By.ID, element_id)))
                return element
            elif element_xpath != '':
                element = wait.until(EC.presence_of_element_located((By.XPATH, element_xpath)))
                return element
        except (StaleElementReferenceException, NoSuchElementException, TimeoutException):
            pass

        if attempt == total_attempt:
            return None
        attempt += 1
        sleep(1)


# Wrapper method for checking that there is at least one element present on a web page.
def wait_for_presence_of_all_elements(element_id='', element_xpath='', total_attempt=1):
    wait_for_page_load()
    attempt = 1
    while True:
        # __exe_logger.info(f"attempt:{attempt}, Waiting for presence of all elements. ")
        try:
            if element_id != '':
                elements = wait.until(EC.presence_of_all_elements_located((By.ID, element_id)))
                return elements
            elif element_xpath != '':
                elements = wait.until(EC.presence_of_all_elements_located((By.XPATH, element_xpath)))
                return elements
        except (StaleElementReferenceException, NoSuchElementException, TimeoutException):
            pass
        
        if attempt == total_attempt:
            return None
        attempt += 1
        sleep(1)
        
        


# Wrapper method for checking an element is visible and enabled such that you can click it.
def wait_until_element_is_clickable(element_id='', element_xpath='', total_attempt=3):
    attempt = 1
    while True:
        # __exe_logger.info(f"attempt:{attempt}, Waiting for elements is clickable. ")
        try:
            if element_id != '':
                element = wait.until(EC.element_to_be_clickable((By.ID, element_id)))
                return element
            elif element_xpath != '':
                element = wait.until(EC.element_to_be_clickable((By.XPATH, element_xpath)))
                return element
        except (StaleElementReferenceException, NoSuchElementException, TimeoutException):
            __exe_logger.error(f"wait_until_element_is_clickable")

        if attempt == total_attempt:
            return None
        
        sleep(1)
        attempt += 1


def find_element_by(element_id='', element_xpath='', total_attempt=1):
    attempt = 1
    while True:
        try:
            if element_id != '':
                element = driver.find_element(By.ID, element_id)
                return element
            elif element_xpath != '':
                element = driver.find_element(By.XPATH, element_xpath)
                return element
        except (StaleElementReferenceException, NoSuchElementException):
            pass

        if attempt == total_attempt:
            return None
        
        sleep(1)
        attempt += 1


# function will return array of elements
def find_elements_by(element_id='', element_xpath='', element_tagname='', total_attempt=1):
    attempt = 1
    while True:
        try:
            if element_id != '':
                element = driver.find_elements(By.ID, element_id)
                return element
            elif element_xpath != '':
                element = driver.find_elements(By.XPATH, element_xpath)
                return element
            elif element_tagname != '':
                element = driver.find_elements(By.TAG_NAME, element_tagname)
                return element
        except (StaleElementReferenceException, NoSuchElementException):
            pass

        if attempt == total_attempt:
            return None
            
        sleep(1)
        attempt += 1


# Wrapper method to execute JavaScript passed as string argument
def execute_script(action_to_perform, element):
    driver.execute_script("arguments[0]." + action_to_perform + "", element)


def execute_javascript(action, element=None):
    return driver.execute_script(action, element)


# Wrapper method to send text input
def sendText(input_element, input_text):
    input_element.send_keys(Keys.CONTROL + "a")
    input_element.send_keys(Keys.DELETE)
    input_element.send_keys(input_text)
    sleep(0.5)

# Wrapper method to send text input
def sendNumber(input_element, NumberText):
    NumberText= str(NumberText)
    num_to_key = {
        0: Keys.NUMPAD0,
        1: Keys.NUMPAD1,
        2: Keys.NUMPAD2,
        3: Keys.NUMPAD3,
        4: Keys.NUMPAD4,
        5: Keys.NUMPAD5,
        6: Keys.NUMPAD6,
        7: Keys.NUMPAD7,
        8: Keys.NUMPAD8,
        9: Keys.NUMPAD9
    }

    input_element.clear()
    for eachNumber in NumberText:
        if int(eachNumber) in num_to_key:
            input_element.send_keys(num_to_key[int(eachNumber)])
            sleep(0.25)

# Wrapper method to send filepath to upload a file
def sendFilePath(input_element, input_path):
    file_path = os.path.normpath(input_path)
    input_element.send_keys(file_path)
    sleep(0.25)


# Wrapper method to input text in a dropdown
def inputTextDropDown(dd_element, dd_input, waitFor: int = 3):
    action_chains.click(dd_element).pause(0.25).send_keys_to_element(dd_element,dd_input).pause(waitFor).send_keys(Keys.ENTER).perform()


# Wrapper method to get current page title
def getPageTitle():
    return driver.title


# Wrapper method to wait for a specified amount of time
def sleep(time_seconds=60):
    t = 1
    while t <= time_seconds:
        print(f"Sleeping {t}/{time_seconds}", end="\r", flush=True)
        time.sleep(1)
        t+=1


# Wrapper method to go to a given URL
def goToURL(url, browser):
    global driver
    driver = initialize.getDriver(browser)
    init_global_param()
    metadata_helper.set_additional_metadata(url, driver)
    driver.maximize_window()
    driver.get(url)


# Wrapper method to click an element
def clickElement(element):
    # action_chains.click(element).send_keys(element_input).perform()
    # element.click()
    action_chains.move_to_element(element).click().perform()

def selenium_click(element: WebElement):
    try:
        if element.is_displayed():
            element.click()
        else:
            raise NoSuchElementException("Element is not displayed.")
    except Exception as e:
        raise Exception(f"An error occurred: {e}")

def getJsonDataWrapper(file_name, user_path=''):
    data_helper = ddtHelper.DdtHelperClass(file_name, user_path)
    return data_helper.readJson()


def currentWindowHandle():
    curr_win_handle = driver.current_window_handle
    return curr_win_handle


def switchToWindow(tab_number):
    driver.switch_to.window(driver.window_handles[tab_number])
    print("Switched to {0} tab".format(tab_number))


def closeTab():
    driver.close()


def getAllWindows():
    all_tab_list = driver.window_handles
    return all_tab_list


def saveToJson(filename, data):
    utils.save_as_json_file(data=data, filename=filename, location=__config["testFolder"])


def takeScreenshot(user_defined_filename="", element_xpath="", reduce_width_by_per=0.75, reduce_height_by_per=0.75,
                   reduce_quality_by_per=50):
    if user_defined_filename == "":
        user_defined_filename = "SS_"
    curr_date, curr_time = utils.getCurrentDateTime(delay_min=0)
    screen_shot_path = str(__config[
                               "testFolder"]) + os.sep + f"{str(user_defined_filename)}_{str(curr_date).replace('/', '_').strip()}_{str(re.sub(r'[:.]', "_", curr_time)).strip()}.png"
    if element_xpath == "":
        driver.save_screenshot(screen_shot_path)
        # screen_shot_path = utils.compress_and_resize_image(screen_shot_path, reduce_width_by_per=reduce_width_by_per,
        #                                                    reduce_height_by_per=reduce_height_by_per,
        #                                                    reduce_quality_by_per=reduce_quality_by_per)
    else:
        wait_for_presence_of_element(element_xpath=element_xpath)
        element = find_element_by(element_xpath=element_xpath)
        # element.screenshot(screen_shot_path)
        location = element.location_once_scrolled_into_view
        size = element.size
        # driver.save_screenshot(screen_shot_path)

        # Calculate the area to capture (extend the area around the element)
        padding = 200  # pixels around the element
        left = location['x'] - padding
        top = location['y'] - padding
        right = location['x'] + size['width'] + padding
        bottom = location['y'] + size['height'] + padding
        driver.save_screenshot(screen_shot_path)  # saves screenshot of entire page
        # screen_shot_path = utils.compress_and_resize_image(screen_shot_path, reduce_width_by_per=reduce_width_by_per,
        #                                                    reduce_height_by_per=reduce_height_by_per,
        #                                                    reduce_quality_by_per=reduce_quality_by_per)
        im = Image.open(screen_shot_path)  # uses PIL library to open image in memory
        im = im.crop((left, top, right, bottom))  # defines crop points
        im.save(screen_shot_path)  # saves new cropped image
    print("Saved image {0}".format(screen_shot_path))
    return screen_shot_path


def capture_screen_for_recording(filename):
    screen_shot_path = str(__config[
                               "testFolder"]) + os.sep + f"{str(filename)}.png"
    driver.save_screenshot(screen_shot_path)


def wait_for_page_load(wait_in_sec=15) -> bool:
    r"""
        Waits for the web page to load.
    """
    attempt = 0
    retry = True
    while (retry) and (attempt < wait_in_sec):
        __exe_logger.info(f'Waiting for page load:{attempt}')
        try:
            if execute_javascript("return document.readyState") == "complete":
                loader = find_elements_by(element_xpath="//*[@*='loading']")
                if loader and len(loader) > 0:
                    retry = True
                else:
                    retry = False
                    return True
        except NoSuchElementException:
            retry = True  # If element is not found, set loading to False
        sleep(1)
        attempt += 1
    return True


def dragAndDrop(source_element, destination_element):
    action_chains.drag_and_drop(source_element, destination_element).perform()

def dragAndDropOffset(source_element, horizontal, vertical):
    action_chains.drag_and_drop_by_offset(source_element, horizontal, vertical).perform()

def clickHoldAndMove(source_element, horizontal, vertical):
    action_chains.click_and_hold(source_element)
    # action_chains.move_by_offset(horizontal, vertical)
    action_chains.move_by_offset(horizontal, vertical).release().perform()


def openElementInNewTab(element):
    driver.execute_script("window.open('%s', '_blank')" % element)
    switchToWindow(-1)


def openUrlInNewTab(url=""):
    if url != "":
        current_url = url
    else:
        # Retrieve the current URL
        current_url = driver.current_url

    # Open a new tab
    driver.execute_script("window.open('');")

    # Switch to the new tab
    switchToWindow(-1)

    # Navigate to the retrieved URL in the new tab
    driver.get(current_url)


def alertPopUp(option, input_text=""):
    alert_box = driver.switch_to.alert
    if input_text:
        sendText(alert_box, input_text)

    if option.lower() in ["yes", "ok"]:
        alert_box.accept()
    elif option.lower() in ["no", "cancel"]:
        alert_box.dismiss()

def scrollToElement(element):
    driver.execute_script("arguments[0].scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });", element)
    sleep(0.5)


def get_attributes(element, attributes: list = []):
    __exe_logger.info("Executing get_attributes")
    # xpath = get_xpath_by(text, tag_name=tag_name, attribute_name=attribute_name, attribute_value=attribute_value, context=context, offset=offset, total_attempts=total_attempts)
    # element = find_element_by(element_xpath=xpath)
    action = """
            var items = {};
            for (index = 0; index < arguments[0].attributes.length; ++index) {
                items[arguments[0].attributes[index].name] = arguments[0].attributes[index].value;
            }
            return items;
            """
    data = {}
    try:
        get_all_attributes = execute_javascript(action, element)

        if attributes != None and attributes != []:
            __exe_logger.info(f"looking for attributes :{attributes}")
            for att in attributes:
                if att in get_all_attributes:
                    data[att] = get_all_attributes[att]
        else:
            __exe_logger.info(f"looking for all the attributes")
            data = get_all_attributes

        __exe_logger.info(f"Attribute Data:{data}")
    except Exception as e:
        __exe_logger.info("Failed to get the attributes")
    return data if data != {} else None


def get_content(element=None, tag_name='', attribute_name='', attribute_value='', context='', offset=0,
                total_attempts=3, max_depth=None):
    __exe_logger.info("Executing get_content")
    if element != None:
        content = element.text
        if content:
            __exe_logger.debug(f"Content : {content}")
            return content
        raise ValueError("No data found for the specified criteria. get_content()")

    if tag_name != '' or attribute_name != '' or attribute_value != '' or context != '':

        from core import element_finder
        element_xpath = element_finder.get_xpath_by(tag_name=tag_name, attribute_name=attribute_name,
                                                    attribute_value=attribute_value, context=context, offset=offset,
                                                    total_attempts=total_attempts, max_depth=max_depth)

        if not element_xpath:
            raise RuntimeError("Failed to find element using element_finder.get_xpath_by()")

        element = find_element_by(element_xpath=element_xpath)
        if element != None:
            content = element.text
            if content:
                __exe_logger.debug(f"Content : {content}")
                return content

        raise ValueError("No data found for the specified criteria. get_content")

    raise ValueError("No valid input specified to retrieve content")


def hoverOverElement(element):
    action_chains.move_to_element(element).perform()


def doubleClick(element):
    action_chains.double_click(element).perform()


def setWinSize(height, width):
    driver.set_window_size(height, width)


def maximizeWinSize():
    driver.maximize_window()


def is_element_in_viewport(element):
    # Get element's location and size
    location = element.location
    size = element.size

    # Get viewport dimensions
    viewport_width = driver.execute_script("return window.innerWidth")
    viewport_height = driver.execute_script("return window.innerHeight")

    # Get element's position relative to the viewport
    element_top = location['y']
    element_bottom = element_top + size['height']
    element_left = location['x']
    element_right = element_left + size['width']

    # Check if the element is within the viewport
    return (element_top >= 0 and element_bottom <= viewport_height and
            element_left >= 0 and element_right <= viewport_width)


def get_current_url():
    return driver.current_url


def get_element_location(element):
    return element.location


def get_element_size(element):
    return element.size


def clear_input(element):
    element.send_keys(Keys.CONTROL + 'a')
    element.send_keys(Keys.BACKSPACE)

def get_window_position():
    # return driver.find_element(By.ID, "loginId").rect
    return driver.get_window_position()


def refreshPage():
    driver.refresh()


def explicitWaitForElementPresence(element_id='', element_xpath='', timeout=30):
    explicit_wait = WebDriverWait(driver, timeout)
    try:
        if element_id != '':
            element = explicit_wait.until(EC.presence_of_element_located((By.ID, element_id)))
            return element
        elif element_xpath != '':
            element = explicit_wait.until(EC.presence_of_element_located((By.XPATH, element_xpath)))
            return element
    except (StaleElementReferenceException, NoSuchElementException, TimeoutException):
        return None


def explicitWaitForElementClickable(element_id='', element_xpath='', timeout=30):
    explicit_wait = WebDriverWait(driver, timeout)
    try:
        if element_id != '':
            element = explicit_wait.until(EC.element_to_be_clickable((By.ID, element_id)))
            return element
        elif element_xpath != '':
            element = explicit_wait.until(EC.element_to_be_clickable((By.XPATH, element_xpath)))
            return element
    except (StaleElementReferenceException, NoSuchElementException, TimeoutException):
        return None

def explicitWaitForElementInvisibility(element_id='', element_xpath='', timeout=30):
    explicit_wait = WebDriverWait(driver, timeout)
    try:
        if element_id != '':
            element = explicit_wait.until(EC.invisibility_of_element_located((By.ID, element_id)))
            return element
        elif element_xpath != '':
            element = explicit_wait.until(EC.invisibility_of_element_located((By.XPATH, element_xpath)))
            return element
    except (StaleElementReferenceException, NoSuchElementException, TimeoutException):
        return None

from ..utils import utils
from ..core import cactions, element_fider_v2
from ..common import initialize
import os
import time
from .. import __exe_logger, __config

GENERIC_TEXT_PLACEHOLDER_XPATH = "//*[text()='Name_Placeholder']"
START_YEAR_FIELD = "//*[text()='Year_Picker_Placeholder']/../..//following-sibling::div//input[@name='year']"
START_MONTH_FIELD = "//*[text()='Month_Picker_Placeholder']/../..//following-sibling::div//input[@name='month']"
START_DAY_FIELD = "//*[text()='Day_Picker_Placeholder']/../..//following-sibling::div//input[@name='day']"
START_HOUR_FIELD = "//*[text()='Hour_Picker_Placeholder']/../..//following::input[@name='hour'][1]"
START_MINUTES_FIELD = "//*[text()='Minutes_Picker_Placeholder']/../..//following::input[@name='minute'][1]"
# GENERIC_CHECKBOX_PLACEHOLDER_XPATH = "//*[text()='Name_Placeholder']/../../..//span[@data-testid='CheckboxInner']"  # "//a[text()='Name_Placeholder']/../../..//input[@name='checkbox']"
GENERIC_ALL_CHECKBOX_PLACEHOLDER_XPATH = "(//span[@data-testid='CheckboxInner'])[1]"
# GENERIC_MULTI_SELECT_DD_XPATH = "//*[text()='Name_Placeholder']/../..//div[contains(@class, 'css-1ilzjc1')]"
GENERIC_TOGGLE_PLACEHOLDER_XPATH = "//*[text()='Name_Placeholder']/../../span[@class != 'sc-ckMVTt eNidUj']"
log = __exe_logger


# A generic method for clicking of elements on the browser
def click(element_text='', element_id='', element_xpath='', element_context='', element_tag_name="", element_attribute='',
          element_attribute_value='', offset=1, max_depth=None):
    global generic_element
    try:
        # GENERIC_ELEMENT_XPATH = GENERIC_TEXT_PLACEHOLDER_XPATH.replace("Name_Placeholder", element_text)
        if element_id != '':
            generic_element = cactions.wait_for_presence_of_element(element_id=element_id)
        elif element_xpath != '':
            generic_element = cactions.wait_for_presence_of_element(element_xpath=element_xpath)
        else:
            GENERIC_ELEMENT_XPATH = element_fider_v2.get_xpath_by(text=element_text, tag_name=element_tag_name, context=element_context,
                                                                attribute_name=element_attribute, attribute_value=element_attribute_value,
                                                                offset=offset, max_depth=max_depth)
            generic_element = cactions.wait_until_element_is_clickable(element_xpath=GENERIC_ELEMENT_XPATH)
        cactions.execute_script("click()", generic_element)
        log.debug("{0} is clicked".format(element_text))
        generic_element = ""
    except Exception as e:
        print("Exception occurred during waiting for object to be clickable. {0}".format(e))


# A generic method for clicking of elements on the browser
def click_2(element_text='', element_id='', element_xpath='', element_context='', element_tag_name="", element_attribute='',
          element_attribute_value='', offset=1, max_depth=None):
    """
    click with  action chains
    """
    global generic_element
    try:
        # GENERIC_ELEMENT_XPATH = GENERIC_TEXT_PLACEHOLDER_XPATH.replace("Name_Placeholder", element_text)
        if element_id != '':
            generic_element = cactions.wait_for_presence_of_element(element_id=element_id)
        elif element_xpath != '':
            generic_element = cactions.wait_for_presence_of_element(element_xpath=element_xpath)
        else:
            GENERIC_ELEMENT_XPATH = element_fider_v2.get_xpath_by(text=element_text, tag_name=element_tag_name, context=element_context,
                                                                attribute_name=element_attribute, attribute_value=element_attribute_value,
                                                                offset=offset, max_depth=max_depth)
            generic_element = cactions.wait_until_element_is_clickable(element_xpath=GENERIC_ELEMENT_XPATH)
        # cactions.execute_script("click()", generic_element)
        ele_props = get_element_props(generic_element)
        cactions.clickElement(generic_element)
        # autoIT.click(loc)
        log.debug("{0} is clicked".format(element_text))
        generic_element = ""
    except Exception as e:
        print("Exception occurred during waiting for object to be clickable. {0}".format(e))

def click_3(element_text='', element_id='', element_xpath='', element_context='', element_tag_name="", element_attribute='',
          element_attribute_value='', offset=1, max_depth=None):
    """
    click with Keydown functions specifically for radix UI elements

    """
    global generic_element
    try:
        # GENERIC_ELEMENT_XPATH = GENERIC_TEXT_PLACEHOLDER_XPATH.replace("Name_Placeholder", element_text)
        if element_id != '':
            generic_element = cactions.wait_for_presence_of_element(element_id=element_id)
        elif element_xpath != '':
            generic_element = cactions.wait_for_presence_of_element(element_xpath=element_xpath)
        else:
            GENERIC_ELEMENT_XPATH = element_fider_v2.get_xpath_by(text=element_text, tag_name=element_tag_name, context=element_context,
                                                                attribute_name=element_attribute, attribute_value=element_attribute_value,
                                                                offset=offset, max_depth=max_depth)
            generic_element = cactions.wait_until_element_is_clickable(element_xpath=GENERIC_ELEMENT_XPATH)
        # cactions.execute_script("click()", generic_element)
        element = cactions.wait_for_presence_of_element( element_xpath=GENERIC_ELEMENT_XPATH)
        # ele_props = get_element_props(generic_element)
        # cactions.clickElement(generic_element)
        if element:
            exec_javascript(__get_js_keyboard_events("keydown","Enter"), element)
        else:
            log.error("Element not found")
            raise 

        # autoIT.click(loc)
        log.debug("{0} is clicked".format(element_text))
        generic_element = ""
    except Exception as e:
        print("Exception occurred during waiting for object to be clickable. {0}".format(e))
        
# A generic method for clicking of elements on the browser
def selenium_click(element_text='', element_id='', element_xpath='', element_context='', element_tag_name="", element_attribute='',
          element_attribute_value='', offset=1, max_depth=None):
    global generic_element
    try:
        # GENERIC_ELEMENT_XPATH = GENERIC_TEXT_PLACEHOLDER_XPATH.replace("Name_Placeholder", element_text)
        if element_id != '':
            generic_element = cactions.wait_for_presence_of_element(element_id=element_id)
        elif element_xpath != '':
            generic_element = cactions.wait_for_presence_of_element(element_xpath=element_xpath)
        else:
            GENERIC_ELEMENT_XPATH = element_fider_v2.get_xpath_by(text=element_text, tag_name=element_tag_name, context=element_context,
                                                                attribute_name=element_attribute, attribute_value=element_attribute_value,
                                                                offset=offset, max_depth=max_depth)
            generic_element = cactions.wait_until_element_is_clickable(element_xpath=GENERIC_ELEMENT_XPATH)
        cactions.selenium_click(generic_element)
        log.debug("{0} is clicked".format(element_text))
        generic_element = ""
    except Exception as e:
        print("Exception occurred during waiting for object to be clickable. {0}".format(e))

def __get_js_keyboard_events(event, key):
    r"""
    Function to create javascript code for keyboard events
    
    Args:
        event: pass event to execute
        key:   pass the key for the keyboard event
        
    Example:
        event: keydown
        key:   Enter
        
    Returns: A javascript 
    """
    js_code = f"""
               var myDropdown = arguments[0];
               var customEvent = new KeyboardEvent("{event}", {{
               bubbles: true,
               cancelable: true,
               key: "{key}",
               keyCode: {ord(key) if len(key) == 1 else 13}
               }});
               myDropdown.dispatchEvent(customEvent);
               """
    return js_code

# A generic method for selecting values from a dropdown

def selectDropdown(dd_input, element_text='', element_id='', element_xpath='', element_context='',
                   element_attribute='', element_attribute_value='', offset=1, waitFor: int = 5, max_depth=None):
    global generic_dd_element
    attempts = 3
    while attempts > 0:
        try:
            if element_id != '':
                generic_dd_element = cactions.wait_for_presence_of_element(element_id=element_id)
            elif element_xpath != '':
                generic_dd_element = cactions.wait_for_presence_of_element(element_xpath=element_xpath)
            else:

                GENERIC_DD_LABEL_XPATH = element_fider_v2.get_xpath_by(text=element_text,
                                                                    tag_name="input", context=element_context,
                                                                    attribute_name=element_attribute,
                                                                    attribute_value=element_attribute_value,
                                                                    offset=offset,
                                                                    max_depth=max_depth)  # "//div[@title='" + dd_field_name + "']/preceding-sibling::div//input"
                generic_dd_element = cactions.wait_for_presence_of_element(element_xpath=GENERIC_DD_LABEL_XPATH)
            # generic_dd_element1 = generic_dd_element.find_element(By.ID, GENERIC_DD_LABEL_XPATH)
            cactions.inputTextDropDown(generic_dd_element, dd_input, waitFor)
            log.debug("{0} select was successful".format(element_text))
            break
        except Exception as e:
            print("Exception occurred during waiting for dropdown object. {0}".format(e))
            if attempts > 0:
                print("trying again!")
        attempts -=1


def fileUpload(file_name, upload_field_name, user_path=""):
    # global generic_upload
    # try:
    #     GENERIC_UPLOAD_XPATH = GENERIC_TEXT_PLACEHOLDER_XPATH.replace("Name_Placeholder", upload_filed_name)
    #     generic_upload = cactions.wait_until_element_is_clickable(element_xpath=GENERIC_UPLOAD_XPATH)

    #     if generic_upload.get_attribute("data-testid") is None:
    #         file_uploader = cactions.wait_for_presence_of_element(
    #             element_xpath=GENERIC_UPLOAD_XPATH + "//../preceding-sibling::input[@type='file']")
    #     else:
    #         file_uploader = cactions.wait_for_presence_of_element(
    #             element_xpath=GENERIC_UPLOAD_XPATH + "//../../preceding-sibling::input[@type='file']")  # Finding the file uploader element on the page
    #     cactions.execute_script("style.display = 'block';", file_uploader)  # Making the web element visible
    #     file_path = utils.findDataPath(file_name, user_path=user_path)
    #     cactions.sendFilePath(file_uploader, str(file_path))  # Uploading the file
    #     log.debug("Uploaded file {0}".format(str(file_path)))
    #     generic_upload = ""
    # except Exception as e:
    #     print("Exception occurred during file upload. {0}".format(e))

    try:
        GENERIC_UPLOAD_XPATH = GENERIC_TEXT_PLACEHOLDER_XPATH.replace("Name_Placeholder", upload_field_name)
        generic_upload = cactions.wait_until_element_is_clickable(element_xpath=GENERIC_UPLOAD_XPATH)
        element_xpath = element_fider_v2.get_xpath_by(attribute_value="file", tag_name='input', attribute_name="type", context=upload_field_name)
        generic_upload = cactions.wait_for_presence_of_element(element_xpath=element_xpath)
        cactions.execute_script("style.display = 'block';", generic_upload)
        file_path = utils.findDataPath(file_name, user_path=user_path)
        cactions.sendFilePath(generic_upload, str(file_path))  # Uploading the file
        log.debug("Uploaded file {0}".format(str(file_path)))
    except Exception as e:
        log.debug("Exception occured in file upload function")


# A generic method to send text input
def clearAndInput(input_text, element_text='', element_id='', element_xpath='', element_context="",
                  element_attribute='', element_attribute_value='', element_tag_name='input', max_depth=None):
    global generic_text_input_element
    try:
        # generic_text_input = cactions.wait_for_presence_of_element(element_xpath="//input[@id='" + element_id + "']")
        if element_id != '':
            generic_text_input_element = cactions.wait_for_presence_of_element(element_id=element_id)
            # cactions.execute_script("click()", generic_text_input)
        elif element_xpath != '':
            generic_text_input_element = cactions.wait_for_presence_of_element(element_xpath=element_xpath)
        else:

            dynamic_xpath = element_fider_v2.get_xpath_by(text=element_text, tag_name=element_tag_name,
                                                        context=element_context, attribute_name=element_attribute,
                                                        attribute_value=element_attribute_value, max_depth=max_depth)

            generic_text_input_element = cactions.wait_for_presence_of_element(element_xpath=dynamic_xpath)
        cactions.sendText(generic_text_input_element, input_text)
    except Exception as e:
        print("Exception occurred entering text. {0}".format(e))

# A generic method to send text input
def clearAndInputNumber(input_text, element_text='', element_id='', element_xpath='', element_context="",
                  element_attribute='', element_attribute_value='', element_tag_name='input', max_depth=None):
    global generic_text_input_element
    try:
        # generic_text_input = cactions.wait_for_presence_of_element(element_xpath="//input[@id='" + element_id + "']")
        if element_id != '':
            generic_text_input_element = cactions.wait_for_presence_of_element(element_id=element_id)
            # cactions.execute_script("click()", generic_text_input)
        elif element_xpath != '':
            generic_text_input_element = cactions.wait_for_presence_of_element(element_xpath=element_xpath)
        else:

            dynamic_xpath = element_fider_v2.get_xpath_by(text=element_text, tag_name=element_tag_name,
                                                        context=element_context, attribute_name=element_attribute,
                                                        attribute_value=element_attribute_value, max_depth=max_depth)

            generic_text_input_element = cactions.wait_for_presence_of_element(element_xpath=dynamic_xpath)
        cactions.sendNumber(generic_text_input_element, input_text)
    except Exception as e:
        print("Exception occurred entering text Numeric. {0}".format(e))


# A generic method to go to a given URL
def navigate(url, browser="chrome"):
    cactions.goToURL(url, browser)


# A generic method to close the browser
def closeBrowser():
    initialize.tearDown()


# A generic method to sleep for a given amount of time
def sleepFor(time_seconds):
    cactions.sleep(time_seconds)


# A generic method to select date (and) time depending on the select_time flag
def calendarPicker(input_name, delay_min=0,
                   select_time=False):  # Delay is optional. If no delay is given then it picks the current time
    datePicker(input_name, delay_min)
    if select_time is True:
        timePicker(input_name, delay_min)


# A generic method to select date
def datePicker(input_name, delay_min):
    cur_date, cur_time = utils.getCurrentDateTime(delay_min)
    cur_date_split = cur_date.split('/')
    global generic_year_picker, generic_month_picker, generic_day_picker
    try:
        # Year picker
        GENERIC_YEAR_XPATH = START_YEAR_FIELD.replace("Year_Picker_Placeholder", input_name)
        generic_year_picker = cactions.wait_until_element_is_clickable(element_xpath=GENERIC_YEAR_XPATH)
        # cactions.execute_script("click()", generic_year_picker)
        # cactions.clickElement(generic_year_picker, int(cur_date_split[0]))
        cactions.sendNumber(generic_year_picker, str(cur_date_split[0]))
        
        # generic_year_picker.send_keys(cur_date_split[0])
        # log.debug(type(cur_date_split[0]))
        # cactions.inputTextDropDown(generic_year_picker, int(cur_date_split[0]))
        generic_year_picker = ""

        # Month picker
        GENERIC_MONTH_XPATH = START_MONTH_FIELD.replace("Month_Picker_Placeholder", input_name)
        generic_month_picker = cactions.wait_until_element_is_clickable(element_xpath=GENERIC_MONTH_XPATH)
        # cactions.execute_script("click()", generic_month_picker)
        # print("Month is: {0}".format(cur_date_split[1]))
        # cactions.clickElement(generic_month_picker, int(cur_date_split[1]))
        cactions.sendNumber(generic_month_picker, str(cur_date_split[1]))
        # cactions.sendText(generic_month_picker, str(6))
        # generic_month_picker.send_keys(cur_date_split[1])
        # log.debug(type(cur_date_split[1]))
        # cactions.inputTextDropDown(generic_month_picker, cur_date_split[1])
        generic_month_picker = ""

        # Day picker
        GENERIC_DAY_XPATH = START_DAY_FIELD.replace("Day_Picker_Placeholder", input_name)
        generic_day_picker = cactions.wait_until_element_is_clickable(element_xpath=GENERIC_DAY_XPATH)
        # cactions.execute_script("click()", generic_day_picker)
        # cactions.clickElement(generic_day_picker, int(cur_date_split[2]))
        cactions.sendNumber(generic_day_picker, str(cur_date_split[2]))
        # cactions.sendText(generic_day_picker, str(4))
        # generic_day_picker.send_keys(cur_date_split[2])
        # log.debug(type(cur_date_split[2]))
        # cactions.inputTextDropDown(generic_day_picker, str(cur_date_split[2]))
        generic_day_picker = ""

    except Exception as e:
        print("Exception occurred during waiting for object to be clickable. {0}".format(e))


# A generic method to select time
def timePicker(input_name, delay_min):
    cur_date, cur_time = utils.getCurrentDateTime(delay_min)
    cur_time_split = cur_time.split(':')
    global generic_hour_picker, generic_minutes_picker
    try:
        # Hour picker
        GENERIC_HOUR_XPATH = START_HOUR_FIELD.replace("Hour_Picker_Placeholder", input_name)
        # log.debug(cur_time_split[0])
        generic_hour_picker = cactions.wait_until_element_is_clickable(element_xpath=GENERIC_HOUR_XPATH)
        # cactions.execute_script("click()", generic_hour_picker)
        # generic_hour_picker.send_keys(cur_time_split[0])
        # cactions.inputTextDropDown(generic_hour_picker, cur_time_split[0])
        # cactions.clickElement(generic_hour_picker, int(cur_time_split[0]))
        cactions.sendNumber(generic_hour_picker, int(cur_time_split[0]))
        generic_hour_picker = ""

        # Minutes picker
        GENERIC_MINUTES_XPATH = START_MINUTES_FIELD.replace("Minutes_Picker_Placeholder", input_name)
        # log.debug(cur_time_split[1])
        generic_minutes_picker = cactions.wait_until_element_is_clickable(element_xpath=GENERIC_MINUTES_XPATH)
        # generic_minutes_picker.click()
        # cactions.execute_script("click()", generic_minutes_picker)
        # generic_minutes_picker.send_keys(cur_time_split[1])
        # cactions.inputTextDropDown(generic_minutes_picker, cur_time_split[1])
        # cactions.clickElement(generic_minutes_picker, int(cur_time_split[1]))
        cactions.sendNumber(generic_minutes_picker, str(cur_time_split[1]))
        # cactions.sendText(generic_minutes_picker, int(9))
        generic_minutes_picker = ""

    except Exception as e:
        print("Exception occurred during waiting for object to be clickable. {0}".format(e))


# A generic method to select a checkbox
def selectCheckBox(element_text='', element_id='', element_xpath='', element_context='', element_attribute='',
                   element_attribute_value='',offset=1, max_depth=None):
    global generic_checkbox_element
    attempt=1
    while attempt <= 3:
        attempt+=1
        try:
            if element_id != '':
                generic_checkbox_element = cactions.wait_for_presence_of_element(element_id=element_id)
            elif element_xpath != '':
                generic_checkbox_element = cactions.wait_for_presence_of_element(element_xpath=element_xpath)
            else:
                GENERIC_CHECKBOX_ELEMENT_XPATH = element_fider_v2.get_xpath_by(text=element_text, tag_name="input",
                                                                            context=element_context,
                                                                            attribute_name=element_attribute,
                                                                            attribute_value=element_attribute_value,
                                                                            offset=offset,
                                                                            max_depth=max_depth)
                generic_checkbox_element = cactions.wait_for_presence_of_element(
                    element_xpath=GENERIC_CHECKBOX_ELEMENT_XPATH)
            if generic_checkbox_element:
                cactions.execute_script("click()", generic_checkbox_element)
                log.debug("{0} checkbox is selected".format(element_text))
                generic_checkbox_element = ""
                break
        except Exception as e:
            print("Exception occurred during waiting to check checkbox. {0}".format(e))
        sleepFor(1)
    


# A generic method to unselect a checkbox
def unSelectCheckBox(element_text='', element_id='', element_xpath='', element_context='', element_attribute='',
                     element_attribute_value='', offset=1, max_depth=None):
    global generic_checkbox_element
    try:
        if element_id != '':
            generic_checkbox_element = cactions.wait_for_presence_of_element(element_id=element_id)
        elif element_xpath != '':
            generic_checkbox_element = cactions.wait_for_presence_of_element(element_xpath=element_xpath)
        else:
            GENERIC_CHECKBOX_ELEMENT_XPATH = element_fider_v2.get_xpath_by(text=element_text, tag_name="input",
                                                                         context=element_context,
                                                                         attribute_name=element_attribute,
                                                                         attribute_value=element_attribute_value,
                                                                         offset=offset,
                                                                         max_depth=max_depth)
            generic_checkbox_element = cactions.wait_for_presence_of_element(
                element_xpath=GENERIC_CHECKBOX_ELEMENT_XPATH)
        if generic_checkbox_element:
            cactions.execute_script("click()", generic_checkbox_element)
            log.debug("{0} checkbox is unselected".format(element_text))
            generic_checkbox_element = ""
    except Exception as e:
        print("Exception occurred during waiting to uncheck checkbox. {0}".format(e))


# A generic method to select all the checkboxes
def selectAll():
    global generic_all_checkbox_element
    try:
        generic_all_checkbox_element = cactions.wait_for_presence_of_element(
            element_xpath=GENERIC_ALL_CHECKBOX_PLACEHOLDER_XPATH)
        if generic_all_checkbox_element.get_attribute("class") == "sc-gXmSlM eTcSpb":
            # log.debug(generic_checkbox_element.get_attribute("class"))
            cactions.execute_script("click()", generic_all_checkbox_element)
            # cactions.clickElement(generic_checkbox_element)
            log.debug("All checkboxes are selected")
            generic_all_checkbox_element = ""
        else:
            log.debug("All the checkboxes are already selected")
    except Exception as e:
        print("Exception occurred during waiting for object to be clickable. {0}".format(e))


# A generic method to unselect all the checkboxes
def unSelectAll():
    global generic_all_checkbox_element
    try:
        generic_all_checkbox_element = cactions.wait_for_presence_of_element(
            element_xpath=GENERIC_ALL_CHECKBOX_PLACEHOLDER_XPATH)
        if generic_all_checkbox_element.get_attribute("class") == "sc-gXmSlM kqpTcu":
            # log.debug(generic_checkbox_element.get_attribute("class"))
            cactions.execute_script("click()", generic_all_checkbox_element)
            # cactions.clickElement(generic_checkbox_element)
            log.debug("All checkboxes are unselected")
            generic_all_checkbox_element = ""
        else:
            log.debug("All the checkboxes are already unselected")
    except Exception as e:
        print("Exception occurred during waiting for object to be clickable. {0}".format(e))


# A generic method to select multiple items from a dropdown
def multiSelectDropDown(*input_text_tuple, element_text='', element_xpath='', element_id='', element_context='',
                        element_attribute='', element_attribute_value=''):
    global generic_multi_select_dd_element
    try:
        if element_id != '':
            generic_multi_select_dd_element = cactions.wait_for_presence_of_element(element_id=element_id)
        elif element_xpath != '':
            generic_multi_select_dd_element = cactions.wait_for_presence_of_element(element_xpath=element_xpath)
        else:
            GENERIC_MULTI_SELECT_ELEMENT_DD_XPATH = element_fider_v2.get_xpath_by(text=element_text, tag_name="input",
                                                                                context=element_context,
                                                                                attribute_name=element_attribute,
                                                                                attribute_value=element_attribute_value)
            generic_multi_select_dd_element = cactions.wait_for_presence_of_element(
                element_xpath=GENERIC_MULTI_SELECT_ELEMENT_DD_XPATH)
            cactions.execute_script("scrollIntoView(true);", generic_multi_select_dd_element)
        for input_text in input_text_tuple:
            cactions.inputTextDropDown(generic_multi_select_dd_element, input_text)
            log.debug("Inputted {0}".format(input_text))

    except Exception as e:
        print("Exception occurred during waiting for multi-select element to be present. {0}".format(e))


# A generic method to turn on a toggle
def toggleOn(element_text='', element_id='', element_xpath='', element_context="", element_attribute='',
             element_attribute_value='', max_depth=None):
    global generic_toggle_on_element
    try:
        if element_id != '':
            generic_toggle_on_element = cactions.wait_for_presence_of_element(element_id=element_id)
        elif element_xpath != '':
            generic_toggle_on_element = cactions.wait_for_presence_of_element(element_xpath=element_xpath)
        else:
            GENERIC_TOGGLE_ON_ELEMENT_XPATH = element_fider_v2.get_xpath_by(text=element_text, context=element_context,
                                                                          attribute_name=element_attribute,
                                                                          attribute_value=element_attribute_value,
                                                                          max_depth=max_depth)
            generic_toggle_on_element = cactions.wait_for_presence_of_element(
                element_xpath=GENERIC_TOGGLE_ON_ELEMENT_XPATH)

        cactions.execute_script("click()", generic_toggle_on_element)
        log.debug("{0} toggle is now on".format(element_text))
        generic_toggle_on_element = ""
    except Exception as e:
        print("Exception occurred during waiting for toggle on element to be present. {0}".format(e))

def scrollToElement(element):
    cactions.scrollToElement(element)

# A generic method to turn off a toggle
def toggleOff(element_text='', element_id='', element_xpath='', element_context='', element_attribute='',
              element_attribute_value='', max_depth=None):
    global generic_toggle_off_element
    try:
        if element_id != '':
            generic_toggle_off_element = cactions.wait_for_presence_of_element(element_id=element_id)
        elif element_xpath != '':
            # sleepFor(2)
            generic_toggle_off_element = cactions.wait_for_presence_of_element(element_xpath=element_xpath)
        else:
            GENERIC_TOGGLE_OFF_ELEMENT_XPATH = element_fider_v2.get_xpath_by(text=element_text, context=element_context,
                                                                           attribute_name=element_attribute,
                                                                           attribute_value=element_attribute_value,
                                                                           max_depth=max_depth)
            generic_toggle_off_element = cactions.wait_for_presence_of_element(
                element_xpath=GENERIC_TOGGLE_OFF_ELEMENT_XPATH)

        cactions.execute_script("click()", generic_toggle_off_element)
        log.debug("{0} toggle is now off".format(element_text))
        generic_toggle_off_element = ""
    except Exception as e:
        print("Exception occurred during waiting for toggle off element to be present. {0}".format(e))


# A generic method to wait for the element to be present
def verifyPresenceOfElement(element_text='', element_id='', element_xpath='', element_context='', element_attribute='',
                            element_attribute_value='', element_tag_name='', offset=1, max_depth=None, total_attempts=3):
    
    params = {"element_text":element_text, "element_id":element_id, "element_xpath":element_xpath, "element_context":element_context, "element_attribute":element_attribute,
                            "element_attribute_value":element_attribute_value, "element_tag_name":element_tag_name, "max_depth":max_depth}
    
    msg = utils.printMsg(params)

    log.debug(f"verify Presence Of Element [{msg}]")

    attempt =1
    while attempt <= total_attempts:
        attempt+=1
        try:
            if element_id != '':
                element = cactions.wait_for_presence_of_element(element_id=element_id)
                log.debug("Element with ID {0} is present".format(element_id))
                return element
            elif element_xpath != '':
                element = cactions.wait_for_presence_of_element(element_xpath=element_xpath)
                log.debug("Element with XPATH {0} is present".format(element_xpath))
                return element
            else:
                dynamic_xpath = element_fider_v2.get_xpath_by(text=element_text, context=element_context,
                                                            attribute_name=element_attribute,
                                                            attribute_value=element_attribute_value,
                                                            offset=offset,
                                                            tag_name=element_tag_name, max_depth=max_depth)
                if dynamic_xpath is not None :
                    element = cactions.wait_for_presence_of_element(element_xpath=dynamic_xpath)
                    # log.debug("Element with XPATH {0} is present".format(element_xpath))
                    log.debug(f"verify Presence Of Element [{msg}] returns=> [{"Found Element" if element != None else "Not Found"}]")
                    return element
                else:
                     log.debug(f"verify Presence Of Element [{msg}] : Element Not Found, Retrying in 1 Second")
        except Exception as e:
            # print("Exception occurred during waiting for verify Presence Of element to be present. {0}".format(e))
            log.warning("Exception occurred during waiting for verify Presence Of element to be present. {0}".format(e))

        sleepFor(1)
    return None



# A generic method to wait for all the elements to be present
def verifyPresenceOfAllElement(element_text='', element_id='', element_xpath=''):
    
    params = {"element_text":element_text, "element_id":element_id, "element_xpath":element_xpath}
    msg = utils.printMsg(params)

    log.debug(f"verify Presence Of all Element [{msg}]")
    attempt =1
    
    while attempt <= 3:
        attempt+=1
        try:
            if element_text !='':
                element = cactions.wait_for_presence_of_all_elements(element_xpath=f"//*[text()='{element_text}' or @*='{element_text}']")
                # log.debug("Element list with parent having text {0} is present".format(element_xpath))
            elif element_id != '':
                element = cactions.wait_for_presence_of_all_elements(element_id=element_id)
                # log.debug("Element list with parent having ID {0} is present".format(element_id))
            elif element_xpath !='':
                element = cactions.wait_for_presence_of_all_elements(element_xpath=element_xpath)
                # log.debug("Element list with parent having XPATH {0} is present".format(element_xpath))



            log.debug(f"verify Presence Of All Elements [{msg}] returns=> [{"Found Element" if element != None else "Not Found"}]")
            return element

        except Exception as e:
            log.warning(
                "Exception occurred during waiting for verify Presence Of all elements to be present. {0}".format(e))
        sleepFor(1)
    return None

# A generic method to wait for the element to be clickable
def verifyElementClickable(element_text='', element_id='', element_xpath='', element_context='', element_attribute='',
                           element_attribute_value='', max_depth=None):
    
    params = {"element_text":element_text, "element_id":element_id, "element_xpath":element_xpath, "element_context":element_context, "element_attribute":element_attribute,
                            "element_attribute_value":element_attribute_value, "max_depth":max_depth}
    msg = utils.printMsg(params)

    log.debug(f"verify Element Clickable [{msg}]")

    attempt =1
    while attempt <= 3:
        attempt+=1
        try:
            if element_id != '':
                element = cactions.wait_until_element_is_clickable(element_id=element_id)
                log.debug("Element with ID {0} is clickable".format(element_id))
            elif element_xpath != '':
                element = cactions.wait_until_element_is_clickable(element_xpath=element_xpath)
                log.debug("Element with XPATH {0} is clickable".format(element_xpath))
            else:
                dynamic_xpath = element_fider_v2.get_xpath_by(text=element_text, context=element_context,
                                                            attribute_name=element_attribute,
                                                            attribute_value=element_attribute_value, max_depth=max_depth)
                # log.debug("Element with XPATH {0} is present".format(element_xpath))

                if dynamic_xpath is not None :
                    element = cactions.wait_until_element_is_clickable(element_xpath=dynamic_xpath)
                    # log.debug("Element with XPATH {0} is present".format(element_xpath))
                    log.debug(f"verify Element Clickable [{msg}] returns=> [{"Found Element" if element != None else "Not Found"}]")
                    
                else:
                    log.debug(f"verify Element Clickable [{msg}] : Element Not Found, Retrying in 1 Second")

            
            if element is not None:
                return element
        except Exception as e:
            log.warning("Exception occurred during waiting for verify element to be Clickable. {0}".format(e))

        sleepFor(1)
    return None


# A generic method to download a file
# TO-DO: make a function to upload a file from cloud
def fileDownload(element_text="", element_tag="",  element_context="", element_xpath="",  move_file_to=''):
    global generic_download, download_file_path
    on_going_download = True
    start_time=time.time()

    # user_download_dir = os.path.join(os.path.expanduser("~"), "Downloads")
    # print("User download directory:", user_download_dir)

    full_path = os.path.normpath(__config['testFolder'])
    os.chdir(full_path)

    expected_files_total = len(sorted(os.listdir(os.getcwd()), key=os.path.getmtime)) + 1

    element_fider_v2.get_xpath_by(element_text, context=element_context)

    if element_xpath != "":
        GENERIC_DOWNLOAD_XPATH = element_xpath
    elif element_text !="":
        GENERIC_DOWNLOAD_XPATH = element_fider_v2.get_xpath_by(element_text, tag_name=element_tag, context=element_context, total_attempts=2)

    try:
        generic_download = cactions.wait_until_element_is_clickable(element_xpath=GENERIC_DOWNLOAD_XPATH)
        cactions.execute_script("click()", generic_download)
        print("Download started.....")
        
        while on_going_download:
            files = sorted(os.listdir(os.getcwd()), key=os.path.getmtime)
            
            newest_file = files[-1]
            extension = os.path.splitext(newest_file)[1]

            download_file_path = os.path.join(full_path, str(newest_file))
            if extension in ['.part', '.crdownload', '.tmp', '.download', '.opdownload', '.filepart', '.partial'] or len(files)!=expected_files_total:
                on_going_download = True
                filesize = os.path.getsize(download_file_path)/(1024*1024)
                print(f"File Downloading,  \t Downloaded : {filesize:.2f} MB", end="\r", flush=True)
                time.sleep(1)
            else:
                on_going_download = False
            
        filesize = os.path.getsize(download_file_path)/(1024*1024)
        print(f"File Downloading,  \t Downloaded : {filesize:.2f} MB")
        print(f"File Downloaded in {time.time()-start_time} seconds")

        if move_file_to != '':
            final_path = utils.move_file(download_file_path, move_file_to)
            print(f"File moved to: {final_path}")
        else:
            final_path = full_path
            print(f"File path without moving: {final_path}")
        print("File download successful at {0}".format(final_path))
        generic_download = ""
    except Exception as e:
        print(f"Exception occurred during file download. {e}")


def getData(*arguments, file_name, user_path=''):
    try:
        data_dict = {}
        json_data = cactions.getJsonDataWrapper(file_name, user_path)

        # Log the retrieved JSON data for debugging
        print(f"Retrieved JSON data: {json_data}")

        for argument in arguments:
            # Log the current argument being checked
            print(f"Checking argument: {argument}")

            if argument in json_data:
                # Log the found key-value pair
                print(f"Found key: {argument} with value: {json_data[argument]}")
                data_dict[argument] = json_data[argument]
            else:
                # Log the missing key
                print(f"Key not found: {argument}")
                data_dict[argument] = "No such key"

        return data_dict
    except Exception as e:
        print(f"Exception occurred while retrieving data from the JSON. {e}")
        return {}


def getDataCSV(arguments, file_name, user_path=''):
    try:
        data_dict = {}
        json_data = cactions.getJsonDataWrapper(file_name, user_path)

        # Log the retrieved JSON data for debugging
        print(f"Retrieved JSON data: {json_data}")
        arguments_list = arguments.split(",")

        for argument in arguments_list:
            # Log the current argument being checked
            argument = argument.replace(' ', '')
            print(f"Checking argument: {argument}")

            if argument in json_data:
                # Log the found key-value pair
                print(f"Found key: {argument} with value: {json_data[argument]}")
                data_dict[argument] = json_data[argument]
            else:
                # Log the missing key
                print(f"Key not found: {argument}")
                data_dict[argument] = "No such key"

        return data_dict
    except Exception as e:
        print(f"Exception occurred while retrieving data from the JSON. {e}")
        return {}


def switchTabs(tab_number, tab_type):
    try:
        if tab_type == "new":
            # If a newly opened tab, then
            print("Moving from {0} to child tab".format(cactions.currentWindowHandle()))
            cactions.switchToWindow(tab_number)
        elif tab_type == "previous":
            # If moving to a previous tab, then close the current tab and then move
            print("Moving from {0} to previous tab".format(cactions.currentWindowHandle()))
            cactions.closeTab()
            cactions.switchToWindow(tab_number)
        else:
            print("Invalid option entered.")
    except Exception as e:
        print(f"Exception occurred while switching the tabs. {e}")


def writeToJson(filename=None, **data):
    for key, value in data.items():
        cactions.saveToJson(filename, {str(key): str(value)})


def saveScreenshot(user_defined_filename="", element_xpath="", reduce_width_by_per=0.2, reduce_height_by_per=0.2,
                   reduce_quality_by_per=20):
    # xp = verifyPresenceOfElement(element_xpath="//h1[normalize-space()='Default Setup']")
    screen_shot_name = cactions.takeScreenshot(user_defined_filename=user_defined_filename, element_xpath=element_xpath,
                                               reduce_width_by_per=reduce_width_by_per,
                                               reduce_height_by_per=reduce_height_by_per,
                                               reduce_quality_by_per=reduce_quality_by_per)
    return screen_shot_name


def dragAndDrop(source_element_text="", destination_element_text="", source_id="", destination_id="", source_xpath="",
                destination_xpath="", element_context="",  element_context2=""):
    try:
        if source_id != '' and destination_id != '':
            source_element = cactions.wait_for_presence_of_element(element_id=source_id)
            destination_element = cactions.wait_for_presence_of_element(element_id=destination_id)
            cactions.dragAndDrop(source_element, destination_element)
        elif source_xpath != '' and destination_xpath != '':
            source_element = cactions.wait_for_presence_of_element(element_xpath=source_xpath)
            destination_element = cactions.wait_for_presence_of_element(element_xpath=destination_xpath)
            cactions.dragAndDrop(source_element, destination_element)
        else:
            source_dynamic_xpath = element_fider_v2.get_xpath_by(text=source_element_text, context=element_context)
            destination_element_xpath = element_fider_v2.get_xpath_by(text=destination_element_text, context=element_context2)
            source_element = cactions.wait_for_presence_of_element(element_xpath=source_dynamic_xpath)
            destination_element = cactions.wait_for_presence_of_element(element_xpath=destination_element_xpath)
            cactions.dragAndDrop(source_element, destination_element)
    except Exception as e:
        print(f"Exception occurred while performing drag and drop. {e}")

def dragAndDropOffset(source_element, left:int=0, right:int=0, top:int=0, bottom:int=0):
    if left ==0 and right==0 and  top==0 and bottom==0:
        raise ValueError("Please provide offset in left, right, top, bottom")

    horizontal = (-left)+right
    vertical = (-top)+bottom
    
    source_element = element_fider_v2.get_xpath_by(text="Drag", context=source_element)
    source_element = cactions.wait_for_presence_of_element(element_xpath=source_element)
    cactions.dragAndDropOffset(source_element, horizontal,vertical)

def clickHoldAndMove(source_element, left:int=0, right:int=0, top:int=0, bottom:int=0):
    if left ==0 and right==0 and  top==0 and bottom==0:
        raise ValueError("Please provide offset in left, right, top, bottom")
    print(left,right,top,bottom)
    horizontal = (-left)+right
    vertical = (-top)+bottom
    print(horizontal, vertical)
    source_element = element_fider_v2.get_xpath_by(text="Drag", context=source_element)
    source_element = cactions.wait_for_presence_of_element(element_xpath=source_element)
    cactions.clickHoldAndMove(source_element,horizontal,vertical)

def openInNewTab(new_url=""):
    try:
        if new_url != "":
            # Open the given URL in a new tab
            cactions.openUrlInNewTab(url=new_url)
        else:
            # Duplicate the current tab
            cactions.openUrlInNewTab()
            pass
    except Exception as e:
        print(f"Exception occurred while trying to open in a new tab. {e}")


def openElementInNewTab(element_text='', element_id='', element_xpath='', element_context=""):
    try:
        if element_xpath != "":
            element = cactions.wait_for_presence_of_element(element_xpath=element_xpath)

        elif element_id != "":
            element = cactions.wait_for_presence_of_element(element_id=element_id)

        else:
            dynamic_xpath = element_fider_v2.get_xpath_by(text=element_text, context=element_context)
            element = cactions.wait_for_presence_of_element(element_xpath=dynamic_xpath)
        cactions.openElementInNewTab(element)
    except Exception as e:
        print(f"Exception occurred while trying to open in a new tab. {e}")


def alertPopUp(option, input_text=""):
    cactions.alertPopUp(option, input_text=input_text)


def containsText(contains_substring):
    elements_list = []
    GENERIC_ITEM_ELEMENT_XPATH = "//*[contains(text(), '" + contains_substring + "') or  contains(@*,'" + contains_substring + "')]"
    try:
        generic_ID_elements = cactions.wait_for_presence_of_all_elements(element_xpath=GENERIC_ITEM_ELEMENT_XPATH)
        if len(generic_ID_elements)>0:
            for element_id in list(generic_ID_elements):
                if element_id.text!="":
                    elements_list.append(element_id.text)
                else:
                    attributes = get_attributes(element_id)
                    if attributes != {} and attributes != None:
                        for attribute in attributes:
                            if contains_substring in attributes[attribute]:
                                elements_list.append(attributes[attribute])
            elements_list = [element for element in elements_list if element != ""]
    except Exception as e:
        log.debug(f"Something went wrong in containsText, exception:{str(e)}")
    return elements_list


def startsWithText(starts_with_substring):
    elements_list = []
    # GENERIC_ITEM_ELEMENT_XPATH = "//*[starts-with(text(), '" + starts_with_substring + "')]"
    GENERIC_ITEM_ELEMENT_XPATH = "//*[starts-with(text(), '" + starts_with_substring + "') or starts-with(@value, '" + starts_with_substring + "')]"
    generic_ID_elements = cactions.wait_for_presence_of_all_elements(element_xpath=GENERIC_ITEM_ELEMENT_XPATH)
    try:
        if generic_ID_elements and len(generic_ID_elements)>0:
            for element_id in list(generic_ID_elements):
                elements_list.append(element_id.text)

            elements_list = [element for element in elements_list if element != ""]
    except Exception as e:
        log.debug(f"Something went wrong in startsWithText, exception:{str(e)}")
    return elements_list


def endsWithText(ends_with_substring):
    elements_list = []
    GENERIC_ITEM_ELEMENT_XPATH = f"//*[substring(text(), string-length(text()) - string-length('{ends_with_substring}') + 1) = '{ends_with_substring}']"  # "//*[starts-with(text(), '" + ends_with_substring + "')]"
    # GENERIC_ITEM_ELEMENT_XPATH = f"//*[substring(lower-case(text()), string-length(lower-case(text())) - string-length('{ends_with_substring}') + 1) = '{ends_with_substring}']"
    try:
        generic_ID_elements = cactions.wait_for_presence_of_all_elements(element_xpath=GENERIC_ITEM_ELEMENT_XPATH)
        if len(generic_ID_elements)>0:
            for element_id in list(generic_ID_elements):
                elements_list.append(element_id.text)
            
            elements_list = [element for element in elements_list if element != ""]
    except Exception as e:
        log.debug(f"Something went wrong in endsWithText, exception:{str(e)}")
    return elements_list


def waitForSpecifiedItemsVisible(itemCount:int, contains_text='', starts_with_text='', ends_with_text='', attempts=3)->bool:
    params = {
        'Item count': itemCount,
        'Contains text': contains_text,
        'Starts with text': starts_with_text,
        'Ends with text': ends_with_text,
        'Total attempts': attempts,
    }

    msg = ""
    for key, value in params.items():
        if value != '' and value != 0:
            msg +=f"{key}: {value}, "

    attempt = 1
    __exe_logger.info(f"waiting for specified items visible'{msg}'")
    if contains_text =="" and starts_with_text=="" and ends_with_text =="":
        raise ValueError("Please enter proper input to this waitForSpecifiedItemsVisible()")
    
    while attempt < attempts:
        __exe_logger.info(f"waiting attempts : '{attempt}'")
        attempt+=1
        total = 0

        if contains_text!="":
            total = containsText(contains_text)

        elif starts_with_text!="":
            total = startsWithText(starts_with_text)

        elif ends_with_text!="":
            total = endsWithText(ends_with_text)

        if total == len(itemCount):
            return True
        
    return False

def get_attributes(element, attributes: list = []):
    r"""
    Retrieves attributes of an HTML element identified by the specified Element
    
    Args:
        Element: WebElement object.
        attributes (list, optional): List of specific attribute names to retrieve.
            If provided, only these attributes are fetched.

    Returns:
        dict: A dictionary where the key is the tag name of the element and the value
              is a dictionary mapping attribute names to their corresponding values.

    Example:
        >>> get_attributes(element)
        {'tag_name': {'attribute1': 'value1', 'attribute2': 'value2'}}

        >>> get_attributes(element, ["attribute1"])
        {'tag_name': {'attribute1': 'value1'}}
    """
    data = cactions.get_attributes(element=element, attributes=attributes)
    return data


def get_content(element=None, tag_name='', attribute_name='', attribute_value='', context='', max_depth=None, offset=0,
                total_attempts=3):
    """
    Retrieves text content

    Args:
    - element: Web element object from which to retrieve text content (optional).
                                or
    - tag_name: Tag name to use for element search (optional).
    - attribute_name: Attribute name to use for element search (optional).
    - attribute_value: Attribute value to use for element search (optional).
    - context: Context for element search (optional).
    - max_depth: max_depth for element search (optional). This refers to level in html structure.
    - offset: Offset for element search (optional, default is 0).
    - total_attempts: Total attempts for element search (optional, default is 15).

    Returns:
    - str: Text content retrieved from the webpage element.
    - if data is empty then return None

    Raises:
    - Exception: If no valid content can be retrieved based on the provided criteria.
    """
    data = cactions.get_content(element=element, tag_name=tag_name, attribute_name=attribute_name,
                                attribute_value=attribute_value, context=context, max_depth=max_depth, offset=offset,
                                total_attempts=total_attempts)
    return data if data else None


# A simple function that will return True if the element is disabled and False if the element is enabled
def isDisabled(element_text='', element_id='', element_xpath='', element_context='', element_attribute='',
               element_attribute_value='', element_tag_name='', attempts=3):
    while attempts>0:
        try:
            element = verifyPresenceOfElement(element_text=element_text, element_id=element_id, element_xpath=element_xpath,
                                                element_context=element_context, element_attribute=element_attribute,
                                                element_attribute_value=element_attribute_value,
                                                element_tag_name=element_tag_name)
            if element is not None:
                print(element.get_property('disabled'))
                if element.get_property('disabled') is None:
                    return False  # since the disabled attribute is not present it means that element is enabled
                else:
                    return element.get_property('disabled')
        except Exception as e:
            print("Element Not Found, Retrying in 1 Second")
            sleepFor(1)
        attempts -= 1



# A simple function that will return True if the element is enabled and False if the element is disabled
def verifyClickEnabled(element_text='', element_id='', element_xpath='', element_context='', element_attribute='',
                       element_attribute_value='', element_tag_name=''):
    element = verifyPresenceOfElement(element_text=element_text, element_id=element_id, element_xpath=element_xpath,
                                      element_context=element_context, element_attribute=element_attribute,
                                      element_attribute_value=element_attribute_value,
                                      element_tag_name=element_tag_name)

    if element.is_enabled():
        return True  # since the disabled attribute is not present it means that element is enabled
    else:
        return False


def hoverElement(element_text='', element_id='', element_xpath='', element_context="", element_attribute='',
                 element_attribute_value='', max_depth=None):
    global generic_hover_element
    try:
        if element_id != '':
            generic_hover_element = cactions.wait_for_presence_of_element(element_id=element_id)
        elif element_xpath != '':
            generic_hover_element = cactions.wait_for_presence_of_element(element_xpath=element_xpath)
        else:
            GENERIC_HOVER_ELEMENT_XPATH = element_fider_v2.get_xpath_by(text=element_text, context=element_context,
                                                                      attribute_name=element_attribute,
                                                                      attribute_value=element_attribute_value,
                                                                      max_depth=max_depth)
            generic_hover_element = cactions.wait_for_presence_of_element(
                element_xpath=GENERIC_HOVER_ELEMENT_XPATH)

        cactions.hoverOverElement(generic_hover_element)
        log.debug("Hovering over {0}".format(generic_hover_element.text))
        generic_hover_element = ""
    except Exception as e:
        print("Exception occurred while trying to hover over the element. {0}".format(e))


def doubleCLickElement(element_text='', element_id='', element_xpath='', element_context="", element_attribute='',
                       element_attribute_value='', max_depth=None):
    global generic_double_click_element
    try:
        if element_id != '':
            generic_double_click_element = cactions.wait_for_presence_of_element(element_id=element_id)
        elif element_xpath != '':
            generic_double_click_element = cactions.wait_for_presence_of_element(element_xpath=element_xpath)
        else:
            GENERIC_DOUBLE_CLICK_ELEMENT_XPATH = element_fider_v2.get_xpath_by(text=element_text, context=element_context,
                                                                             attribute_name=element_attribute,
                                                                             attribute_value=element_attribute_value,
                                                                             max_depth=max_depth)
            generic_double_click_element = cactions.wait_for_presence_of_element(
                element_xpath=GENERIC_DOUBLE_CLICK_ELEMENT_XPATH)

        cactions.doubleClick(generic_double_click_element)
        log.debug("Double clicking {0}".format(generic_double_click_element.text))
        generic_double_click_element = ""
    except Exception as e:
        print("Exception occurred while trying to double click on the element. {0}".format(e))


def setCurrentWindowSize(height, width):
    cactions.setWinSize(height, width)


def maximizeCurrentWindowSize():
    cactions.maximizeWinSize()


def get_current_url():
    return cactions.get_current_url()


def wait_for_page_load(timeout=15):
    r"""
    Function to wait for the page to load
    
    Args:
        timeout: a timer to wait for the page to load
    """
    cactions.wait_for_page_load(timeout)


def exec_javascript(action, ele=None):
    r"""
    Function to execute Javascript function on an element
    
    Args:
        action: javascript code to execute.
        ele:    WebElement to run action on
    """
    cactions.execute_javascript(action, ele)
 

def clear_input(element_text='', element_id='', element_xpath='', element_context="",
                  element_attribute='', element_attribute_value='', element_tag_name='input', max_depth=None):
    global generic_text_input_element
    try:
        # generic_text_input = cactions.wait_for_presence_of_element(element_xpath="//input[@id='" + element_id + "']")
        if element_id != '':
            generic_text_input_element = cactions.wait_for_presence_of_element(element_id=element_id)
            # cactions.execute_script("click()", generic_text_input)
        elif element_xpath != '':
            generic_text_input_element = cactions.wait_for_presence_of_element(element_xpath=element_xpath)
        else:

            dynamic_xpath = element_fider_v2.get_xpath_by(text=element_text, tag_name=element_tag_name,
                                                        context=element_context, attribute_name=element_attribute,
                                                        attribute_value=element_attribute_value, max_depth=max_depth)

            generic_text_input_element = cactions.wait_for_presence_of_element(element_xpath=dynamic_xpath)
        cactions.clear_input(generic_text_input_element)
    except Exception as e:
        print("Exception occurred entering text. {0}".format(e))
 
def get_element_props(element):
    location = cactions.get_element_location(element)
    size = cactions.get_element_size(element)
    return {location:location,size:size}


def refreshPage():
    cactions.refreshPage()


# A generic method to wait for the element to be present
def waitForElementPresence(element_id='', element_xpath='', element_text='', timeout=30):
    element = None
    try:
        if element_id != '':
            log.debug(f"Waiting for element ID:{element_id} to be presence within timeout of {timeout} seconds")
            element = cactions.explicitWaitForElementPresence(element_id=element_id, timeout=timeout)
        elif element_xpath != '':
            log.debug(f"Waiting for element XPATH:{element_xpath} to be presence within timeout of {timeout} seconds")
            element = cactions.explicitWaitForElementPresence(element_xpath=element_xpath, timeout=timeout)
        elif element_text != '':
            log.debug(f"Waiting for element Text:{element_text} to be presence within timeout of {timeout} seconds")
            element = cactions.explicitWaitForElementPresence(element_xpath=f"//*[text()='{element_text}']", timeout=timeout)

        if element is not None:
            log.debug("Element is presence")
        else:
            log.debug("Element is not presence")

    except Exception as e:
        log.warning("Exception occurred during waiting for element to be presence. {0}".format(e))

    return element


# A generic method to wait for the element to be clickable
def waitForElementClickable(element_id='', element_xpath='', element_text='', timeout=30):
    element = None
    try:
        if element_id != '':
            log.debug(f"Waiting for element ID:{element_id} to be clickable within timeout of {timeout} seconds")
            element = cactions.explicitWaitForElementClickable(element_id=element_id, timeout=timeout)
        elif element_xpath != '':
            log.debug(f"Waiting for element XPATH:{element_xpath} to be clickable within timeout of {timeout} seconds")
            element = cactions.explicitWaitForElementClickable(element_xpath=element_xpath, timeout=timeout)
        elif element_text != '':
            log.debug(f"Waiting for element Text:{element_text} to be clickable within timeout of {timeout} seconds")
            element = cactions.explicitWaitForElementClickable(element_xpath=f"//span[text()='{element_text}']/parent::button", timeout=timeout)

        if element is not None:
            log.debug("Element is clickable")
        else:
            log.debug("Element is not clickable")

    except Exception as e:
        log.warning("Exception occurred during waiting for element to be clickable. {0}".format(e))

    return element

# A generic method to wait for the element to be invisible
def waitForElementInvisibility(element_id='', element_xpath='', element_text='', timeout=30):
    element = None
    try:
        if element_id != '':
            log.debug(f"Waiting for element ID:{element_id} to be invisible within timeout of {timeout} seconds")
            element = cactions.explicitWaitForElementInvisibility(element_id=element_id, timeout=timeout)
        elif element_xpath != '':
            log.debug(f"Waiting for element XPATH:{element_xpath} to be invisible within timeout of {timeout} seconds")
            element = cactions.explicitWaitForElementInvisibility(element_xpath=element_xpath, timeout=timeout)
        elif element_text != '':
            log.debug(f"Waiting for element Text:{element_text} to be invisible within timeout of {timeout} seconds")
            element = cactions.explicitWaitForElementInvisibility(element_xpath=f"//span[text()='{element_text}']/parent::button", timeout=timeout)

        if element is not None:
            log.debug("Element is present")
        else:
            log.debug("Element is not present")

    except Exception as e:
        log.warning("Exception occurred during waiting for element to be invisible. {0}".format(e))

    return element


def stopCapturingBrowserlogs():
    cactions.stopCapturingBrowserlogs()
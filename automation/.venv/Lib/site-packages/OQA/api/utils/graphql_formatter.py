import json

# helper:converts array of paths to dict so that easier to create string structure
# i.e ["message","message.txt"] -> {"message":{"txt":{}}}
def __convert_paths_to_dict(data,obj={}):
    split_path=data.split(".",1)
    if split_path[0] not in obj:
        obj[split_path[0]]={}
    if len(split_path)>1:
            obj[split_path[0]]=__convert_paths_to_dict(split_path[1],obj[split_path[0]])

    return obj

# converts paths dict to string 
# i.e  {"message":{"txt":{}}}   -> {
#  message{
#      txt
#   }
#  }
def __convert_dict_to_graphQlmask(obj:dict):
    mask=""
    for k,items in obj.items():
        mask+=k
        sub_items=items.keys()
        if len(sub_items)>0:
            sub_mask=__convert_dict_to_graphQlmask(items)
            mask+=f"{{\n{sub_mask}}}\n"
        else:
            mask+="\n"
    return mask

# get all keys from a dictionary/nested dictionary.
def __get_all_keys_from_dict(obj:dict):
    keys=[]
    for k,v in obj.items():

        keys.append(k)
        if isinstance(v,dict):
            keys.extend(__get_all_keys_from_dict(v))
        elif isinstance(v,list):
            for i in v:
                if isinstance(i,dict):
                    keys.extend(__get_all_keys_from_dict(i))
    return keys

# Uses the identifier to detect enums and then remove quotes and identifier from give enum
# i.e "ENUM__STRING" -> STRING
def __format_enums(params:str,identifier="ENUM__"):
    x=params.find(identifier)
    while x>0:
        x=params.find(identifier)
        y=params[x:].find("\"")
        value=params[x:x+y]
        params=params.replace(f"\"{value}\"",value.replace(identifier,""))
    return params

# parser to convert params dict to string 
def format_params_and_get_values(params:dict):
    param_type={

    }
    param_value={

    }
    for k,v in params.items():
        assert "type" in v
        param_type[k]=v['type']
        assert "value" in v 
        param_value[k]=v['value']


    params_string=json.dumps(param_type,separators=(",",":"))
    params_string=params_string[1:len(params_string)-1]
    function_param=[]
    for key in param_type.keys():
        params_string=params_string.replace(f"\"{key}\":",f"${key}:")
        function_param.append(f"{key}:${key}")
    
    
    params_string=params_string.replace("\"","")
    return params_string,",".join(function_param),param_value

# converts array of paths to dict so that easier to create string structure
# i.e ["message","message.txt"] -> {"message":{"txt":{}}}
def stringify_mask(mask:list):
    stringified_mask=""
    if len(mask)>0:
        obj={}
        sorted(mask)
        for path in mask:
            split_path=path.split(".",1)
            if split_path[0] not in obj:
                obj[split_path[0]]={}
            if len(split_path)>1:
                obj[split_path[0]]=__convert_paths_to_dict(split_path[1],obj[split_path[0]])
        stringified_mask=__convert_dict_to_graphQlmask(obj)
    return stringified_mask

'''
Generates graphql query structure
returns query and variables
'''
def generate_query(method:str,function_name:str, required_data:list,params:dict=None):
    params_string=None
    variables={}
    function_param=None
    if  params:
        params_string,function_param,variables=format_params_and_get_values(params)
        assert len(params_string)>0
        assert len(variables.keys())>0
    mask=stringify_mask(required_data)
    params_string=f"({params_string})" if params_string else ''
    function_param=f"({function_param})" if function_param else ''

    query_body=f'{function_name}{function_param}{{\n{mask}\n}}'
    query=f"{method} {function_name}Query{params_string}{{\n{query_body}\n}}"

    return query,variables